/**
 * MCP tools for memory management
 */
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { MemoryFilter, VectorStore } from "../types/memory.js";
import { MemoryNotFoundError, formatErrorResponse } from "../utils/errors.js";

/**
 * Register all memory-related tools with the MCP server
 * 
 * @param server - The MCP server instance
 * @param vectorStore - The vector store implementation to use
 */
export function registerMemoryTools(server: McpServer, vectorStore: VectorStore): void {
  // Memory store tool
  server.tool(
    "memory-store",
    "Store text in the memory database",
    {
      text: z.string().min(1).describe("Text content to store"),
      source: z.string().optional().describe("Source of the information"),
      tags: z.array(z.string()).optional().describe("Tags for categorization"),
      metadata: z.record(z.any()).optional().describe("Additional metadata"),
    },
    async ({ text, source, tags, metadata = {} }) => {
      try {
        // Get an embedding for the text
        const item = await vectorStore.add({
          text,
          metadata: {
            timestamp: Date.now(),
            source: source || "user",
            tags: tags || [],
            ...metadata,
          },
          embedding: [], // This will be generated by the vector store
        });

        return {
          content: [
            {
              type: "text",
              text: `Memory stored successfully with ID: ${item.id}`,
            },
          ],
          json_response: {
            id: item.id,
            success: true,
          },
        };
      } catch (error) {
        const errorResponse = formatErrorResponse(error);
        
        return {
          content: [
            {
              type: "text",
              text: `Failed to store memory: ${errorResponse.details}`,
            },
          ],
          json_response: {
            success: false,
            ...errorResponse,
          },
        };
      }
    },
  );

  // Memory retrieve tool
  server.tool(
    "memory-retrieve",
    "Retrieve memories by semantic similarity",
    {
      query: z.string().min(1).describe("Text to search for"),
      limit: z.number().positive().default(5).describe("Maximum number of results"),
      filter: z
        .object({
          tags: z.array(z.string()).optional().describe("Filter by tags"),
          source: z.string().optional().describe("Filter by source"),
          fromDate: z.number().optional().describe("Filter by timestamp (from)"),
          toDate: z.number().optional().describe("Filter by timestamp (to)"),
        })
        .passthrough()
        .optional()
        .describe("Filter criteria"),
    },
    async ({ query, limit, filter }) => {
      try {
        const results = await vectorStore.searchByText(query, limit, filter as MemoryFilter);

        if (results.length === 0) {
          return {
            content: [
              {
                type: "text",
                text: "No matching memories found.",
              },
            ],
            json_response: {
              memories: [],
              count: 0,
            },
          };
        }

        const formattedResults = results.map((result) => {
          const { item, score } = result;
          return [
            `ID: ${item.id}`,
            `Score: ${score.toFixed(4)}`,
            `Text: ${item.text}`,
            `Source: ${item.metadata.source}`,
            `Tags: ${item.metadata.tags.join(", ") || "none"}`,
            `Timestamp: ${new Date(item.metadata.timestamp).toISOString()}`,
            "---",
          ].join("\n");
        });

        return {
          content: [
            {
              type: "text",
              text: `Found ${results.length} memories:\n\n${formattedResults.join("\n")}`,
            },
          ],
          json_response: {
            memories: results.map((result) => ({
              id: result.item.id,
              text: result.item.text,
              metadata: result.item.metadata,
              score: result.score,
            })),
            count: results.length,
          },
        };
      } catch (error) {
        const errorResponse = formatErrorResponse(error);
        
        return {
          content: [
            {
              type: "text",
              text: `Failed to retrieve memories: ${errorResponse.details}`,
            },
          ],
          json_response: {
            success: false,
            ...errorResponse,
          },
        };
      }
    },
  );

  // Memory update tool
  server.tool(
    "memory-update",
    "Update existing memory",
    {
      id: z.string().describe("ID of the memory to update"),
      text: z.string().optional().describe("New text content"),
      source: z.string().optional().describe("New source"),
      tags: z.array(z.string()).optional().describe("New tags"),
      metadata: z.record(z.any()).optional().describe("Additional metadata to update"),
    },
    async ({ id, text, source, tags, metadata = {} }) => {
      try {
        // Check if the memory exists
        const existingItem = await vectorStore.get(id);
        if (!existingItem) {
          throw new MemoryNotFoundError(id);
        }

        // Prepare metadata updates
        const metadataUpdates: Record<string, any> = {};
        if (source) metadataUpdates.source = source;
        if (tags) metadataUpdates.tags = tags;
        
        // Add other metadata fields
        for (const [key, value] of Object.entries(metadata)) {
          metadataUpdates[key] = value;
        }

        // Apply updates
        const updates: any = {};
        if (text) updates.text = text;
        if (Object.keys(metadataUpdates).length > 0) {
          updates.metadata = metadataUpdates;
        }

        const updatedItem = await vectorStore.update(id, updates);
        if (!updatedItem) {
          throw new MemoryNotFoundError(id);
        }

        return {
          content: [
            {
              type: "text",
              text: `Memory updated successfully: ${id}`,
            },
          ],
          json_response: {
            id,
            success: true,
            item: updatedItem,
          },
        };
      } catch (error) {
        const errorResponse = formatErrorResponse(error);
        
        return {
          content: [
            {
              type: "text",
              text: `Failed to update memory: ${errorResponse.details}`,
            },
          ],
          json_response: {
            success: false,
            ...errorResponse,
          },
        };
      }
    },
  );

  // Memory delete tool
  server.tool(
    "memory-delete",
    "Delete a memory",
    {
      id: z.string().describe("ID of the memory to delete"),
    },
    async ({ id }) => {
      try {
        const deleted = await vectorStore.delete(id);
        if (!deleted) {
          throw new MemoryNotFoundError(id);
        }

        return {
          content: [
            {
              type: "text",
              text: `Memory deleted successfully: ${id}`,
            },
          ],
          json_response: {
            id,
            success: true,
          },
        };
      } catch (error) {
        const errorResponse = formatErrorResponse(error);
        
        return {
          content: [
            {
              type: "text",
              text: `Failed to delete memory: ${errorResponse.details}`,
            },
          ],
          json_response: {
            success: false,
            ...errorResponse,
          },
        };
      }
    },
  );

  // Memory stats tool
  server.tool(
    "memory-stats",
    "Get statistics about the memory store",
    {},
    async () => {
      try {
        const stats = await vectorStore.getStats();

        const formattedStats = [
          `Total memories: ${stats.totalItems}`,
          `Unique sources: ${stats.uniqueSources.join(", ") || "none"}`,
          `Unique tags: ${stats.uniqueTags.join(", ") || "none"}`,
          `Oldest memory: ${stats.oldestTimestamp ? new Date(stats.oldestTimestamp).toISOString() : "none"}`,
          `Newest memory: ${stats.newestTimestamp ? new Date(stats.newestTimestamp).toISOString() : "none"}`,
        ].join("\n");

        return {
          content: [
            {
              type: "text",
              text: `Memory store statistics:\n\n${formattedStats}`,
            },
          ],
          json_response: stats,
        };
      } catch (error) {
        const errorResponse = formatErrorResponse(error);
        
        return {
          content: [
            {
              type: "text",
              text: `Failed to get memory stats: ${errorResponse.details}`,
            },
          ],
          json_response: {
            success: false,
            ...errorResponse,
          },
        };
      }
    },
  );
}
